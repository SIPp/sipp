/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample C++ project to get you started.
 * For more details take a look at the Building C++ applications and libraries chapter in the Gradle
 * User Manual available at https://docs.gradle.org/7.0.2/userguide/building_cpp_projects.html
 */

plugins {
    // Apply the cpp-application plugin to add support for building C++ executables
    id 'cpp-application'

    // Apply the cpp-unit-test plugin to add support for building and running C++ test executables
    //id 'cpp-unit-test'
}

// Set the target operating system and architecture for this application
application {
    targetMachines.add(machines.linux.x86_64)
}

task cleanrpc(type:Exec) {

  doFirst {
    println("Cleaning files for sip:rpc")
  }
  workingDir 'rpc'

  //on linux
  commandLine 'make','clean'

  //store the output instead of printing to the console:
  standardOutput = new ByteArrayOutputStream()

  //extension method stopTomcat.output() can be used to obtain the output:
  ext.output = {
    return standardOutput.toString()
  }

  doLast {
    println("Finished cleaning files for sipp:rpc")
  }
}

task cleansipp(type:Exec) {

  doFirst {
    println("Cleaning files")
  }
  workingDir '.'

  //on linux
  commandLine 'make','clean'

  //store the output instead of printing to the console:
  standardOutput = new ByteArrayOutputStream()

  //extension method stopTomcat.output() can be used to obtain the output:
  ext.output = {
    return standardOutput.toString()
  }

  doLast {
    println("Finished cleaning files")
  }

if (!file("./Makefile").exists()){
  enabled = false
}

}

task buildrpc(type:Exec) {

  doFirst {
    println("Running build rpc for sipp")
  }

  dependsOn tasks.cleanrpc

  workingDir 'rpc'

  //on linux
  commandLine 'make'

  //store the output instead of printing to the console:
  standardOutput = new ByteArrayOutputStream()

  //extension method stopTomcat.output() can be used to obtain the output:
  ext.output = {
    return standardOutput.toString()
  }

  doLast {
    if (!file("rpc/sa_ctl").exists()){
      throw new GradleException('Failed build sipp:rpc')
      //throw new RuntimeException('Failed build sipp:rpc')
    } else {
      println("Finished build sipp:rpc")
    }
  }
}

task buildsipp(type:Exec) {

  dependsOn tasks.cleansipp
  workingDir '.'

  doFirst {
    println("Running build sipp")
    if (!file("./Makefile").exists()){
      commandLine './build.sh'
    } else {
      //on linux
      commandLine 'make'
    }

    //store the output instead of printing to the console:
    standardOutput = new ByteArrayOutputStream()

    //extension method stopTomcat.output() can be used to obtain the output:
    ext.output = {
    return standardOutput.toString()
    }
  }

  doLast {
    if (!file("sipp").exists()){
      throw new GradleException('Failed build sipp')
      //throw new RuntimeException('Failed build sipp')
    } else {
      println("Finished build sipp")
    }
  }
}

task packsipp(type: Copy) {

    doFirst {
      println("Running pack sipp")
    }

    dependsOn tasks.buildrpc
    dependsOn tasks.buildsipp

    from('.') {
        include 'sipp'
    }
    from('rpc') {
        include 'sa_ctl'
    }
    into 'build/bin'
    exclude '**/*.bak'

    includeEmptyDirs = false

    doLast {
      if (!file("$buildDir/bin/sipp").exists()){
        throw new GradleException('Failed pack sipp')
        //throw new RuntimeException('Failed pack sipp')
      } else if (!file("$buildDir/bin/sa_ctl").exists()){
        throw new GradleException('Failed pack sipp:rpc')
        //throw new RuntimeException('Failed pack sipp:rpc')
      } else {
        println("Finished running pack sipp")
      }
    }
}

